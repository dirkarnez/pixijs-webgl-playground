{"version":3,"file":"LayoutContainer.cjs","sources":["../../src/components/LayoutContainer.ts"],"sourcesContent":["import {\n    Container,\n    type ContainerChild,\n    type ContainerOptions,\n    type DestroyOptions,\n    Graphics,\n    Rectangle,\n    Ticker,\n} from 'pixi.js';\nimport { BoxSizing, Edge } from 'yoga-layout/load';\nimport { type ComputedLayout } from '../core/types';\nimport { Trackpad, type TrackpadOptions } from './trackpad/Trackpad';\n\nfunction bindAndPreserve<T extends object, K extends keyof T>(\n    base: T,\n    source: Container,\n    methodNames: K[],\n): Pick<T, K> {\n    const bound = {} as Pick<T, K>;\n    const proto = Object.getPrototypeOf(base);\n\n    for (const name of methodNames) {\n        const method = proto[name];\n\n        bound[name] = method.bind(base);\n        (base as any)[name] = (...args: any[]) => (source as any)[name](...args);\n    }\n\n    return bound;\n}\n\n/**\n * Options for configuring the layout container.\n * @property {TrackpadOptions} [trackpad] - Options to configure the trackpad for scrolling\n */\nexport interface LayoutContainerOptions extends ContainerOptions {\n    /** Options to configure the trackpad for scrolling */\n    trackpad?: TrackpadOptions;\n    /** A container to be used for the background */\n    background?: ContainerChild;\n}\n\n/**\n * A specialized container that serves as an overflow container for scrolling content.\n */\nexport interface OverflowContainer extends Container {\n    isOverflowContainer: boolean;\n}\n\n/**\n * A container that behaves like an HTML div element with flexbox-style layout capabilities.\n *\n * Supports objectFit, objectPosition, backgroundColor, borderColor, and overflow\n *\n * @example\n * ```typescript\n * // Create a container with background and border\n * const container = new LayoutContainer();\n * container.layout = {\n *     width: 300,\n *     height: 200,\n *     backgroundColor: 0xFF0000,\n *     borderWidth: 2,\n *     borderColor: 0x000000,\n *     borderRadius: 8,\n *     padding: 16,\n *     flexDirection: 'row',\n *     justifyContent: 'center',\n *     alignItems: 'center',\n * };\n *\n * // Create child elements\n * const child1 = new Container();\n * child1.layout = { flex: 1 };\n * const child2 = new Container();\n * child2.layout = { flex: 2 };\n *\n * // Add children which will be positioned using flex layout\n * container.addChild(child1, child2);\n * ```\n */\nexport class LayoutContainer extends Container {\n    /** Graphics object used for rendering background and borders */\n    public background: Container | Graphics;\n    public stroke: Graphics = new Graphics({ label: 'stroke' });\n\n    /** The container that holds the overflow content */\n    public overflowContainer: OverflowContainer = new Container({\n        label: 'overflowContainer',\n    }) as OverflowContainer;\n\n    /** Access to original Container methods */\n    public readonly containerMethods: Readonly<{\n        addChild: <T extends ContainerChild>(...children: T[]) => T;\n        addChildAt: <T extends ContainerChild>(child: T, index: number) => T;\n        removeChild: <T extends ContainerChild>(...children: T[]) => T;\n        removeChildAt: (index: number) => ContainerChild;\n        getChildAt: (index: number) => ContainerChild;\n        getChildIndex: (child: ContainerChild) => number;\n        setChildIndex: (child: ContainerChild, index: number) => void;\n        getChildByName: (name: string, deep?: boolean) => ContainerChild | null;\n        removeChildren: (beginIndex?: number, endIndex?: number) => ContainerChild[];\n        sortChildren: () => void;\n        swapChildren: (child1: ContainerChild, child2: ContainerChild) => void;\n        reparentChild: <T extends ContainerChild[]>(...children: T) => T[0];\n        reparentChildAt: <T extends ContainerChild>(child: T, index: number) => T;\n        getChildByLabel: (label: string, deep?: boolean) => ContainerChild | null;\n        getChildrenByLabel: (label: string, deep?: boolean, out?: ContainerChild[]) => ContainerChild[];\n    }>;\n\n    /** The trackpad for handling scrolling */\n    protected _trackpad: Trackpad;\n\n    /** Mask for overflow handling */\n    private _mask: Graphics = new Graphics();\n\n    /** Whether or not the background was created by the user */\n    private _isUserBackground: boolean = false;\n\n    /** The hit area for the container */\n    private _hitArea = new Rectangle();\n\n    constructor(params: LayoutContainerOptions = {}) {\n        const { layout, trackpad, background, children, ...options } = params;\n\n        super(options);\n        this.layout = layout ?? {};\n        children?.forEach((child) => this.addChild(child));\n\n        this.overflowContainer.isOverflowContainer = true;\n        this.background = background ?? new Graphics({ label: 'background' });\n        this._isUserBackground = !!background;\n\n        this.addChild(this.background, this.overflowContainer, this._mask, this.stroke);\n        // Preserve original Container methods and bind them to use the overflowContainer\n        this.containerMethods = bindAndPreserve(this, this.overflowContainer, [\n            'addChild',\n            'addChildAt',\n            'removeChild',\n            'removeChildAt',\n            'getChildAt',\n            'getChildIndex',\n            'setChildIndex',\n            'getChildByName',\n            'removeChildren',\n            'sortChildren',\n            'swapChildren',\n            'reparentChild',\n            'reparentChildAt',\n            'getChildByLabel',\n            'getChildrenByLabel',\n        ]) as typeof this.containerMethods;\n\n        this._trackpad = new Trackpad({\n            constrain: true,\n            ...trackpad,\n        });\n        this.eventMode = 'static';\n        this.on('pointerdown', (e) => this._trackpad.pointerDown(e.global));\n        this.on('pointerup', () => this._trackpad.pointerUp());\n        this.on('pointerupoutside', () => this._trackpad.pointerUp());\n        this.on('pointermove', (e) => this._trackpad.pointerMove(e.global));\n        this.on('pointercancel', () => this._trackpad.pointerUp());\n        this.on('wheel', (e) => {\n            const overflow = this.layout?.style.overflow;\n\n            if (overflow !== 'scroll') {\n                return;\n            }\n            const shift = e.shiftKey ? 1 : 0;\n            const deltaX = e.deltaX * (shift ? 1 : -1);\n            const deltaY = e.deltaY * (shift ? -1 : 1);\n\n            const targetX = this._trackpad.xAxis.value - deltaX;\n            const targetY = this._trackpad.yAxis.value - deltaY;\n\n            this._trackpad.xAxis.value = Math.max(\n                this._trackpad.xAxis.max,\n                Math.min(this._trackpad.xAxis.min, targetX),\n            );\n            this._trackpad.yAxis.value = Math.max(\n                this._trackpad.yAxis.max,\n                Math.min(this._trackpad.yAxis.min, targetY),\n            );\n        });\n        Ticker.shared.add(this.update, this);\n    }\n\n    /**\n     * Computes the layout data for this container based on yoga calculations and draws the background.\n     * @param computedLayout - The computed layout data from yoga\n     * @returns Position and scale information for the container\n     * @internal\n     */\n    override computeLayoutData(computedLayout: ComputedLayout) {\n        this._drawBackground(computedLayout);\n        this._hitArea.width = computedLayout.width;\n        this._hitArea.height = computedLayout.height;\n        this.hitArea = this._hitArea;\n\n        return {\n            x: computedLayout.left,\n            y: computedLayout.top,\n            offsetX: 0,\n            offsetY: 0,\n            scaleX: 1,\n            scaleY: 1,\n        };\n    }\n\n    /**\n     * Updates the container mask based on overflow settings\n     * @param width - Container width\n     * @param height - Container height\n     * @param radius - Border radius\n     */\n    protected _updateMask(width: number, height: number, radius: number = 0) {\n        this._mask.clear();\n        this._mask.roundRect(0, 0, width, height, radius);\n        this._mask.fill(0x0000ff);\n        this._mask.roundRect(1, 1, width - 2, height - 2, radius);\n        this._mask.cut();\n        this._mask.roundRect(1, 1, width - 2, height - 2, radius);\n        this._mask.fill(0x00ff00);\n        this._mask.cut();\n    }\n\n    protected _updateBackground(computedLayout: ComputedLayout) {\n        const layoutStyles = this.layout!.style;\n        const { backgroundColor, borderRadius } = layoutStyles;\n\n        if (this._isUserBackground) {\n            this.background.position.set(0, 0);\n            this.background.setSize(computedLayout.width, computedLayout.height);\n        } else {\n            const background = this.background as Graphics;\n\n            background.clear();\n            background.roundRect(0, 0, computedLayout.width, computedLayout.height, borderRadius ?? 0);\n            // eslint-disable-next-line no-eq-null, eqeqeq\n            if (backgroundColor != null) {\n                background.fill({ color: backgroundColor });\n            }\n        }\n    }\n\n    /**\n     * Draws the container's background including:\n     * - Background color\n     * - Border\n     * - Border radius\n     *\n     * @param computedLayout - The computed layout data from yoga\n     * @protected\n     */\n    protected _drawBackground(computedLayout: ComputedLayout) {\n        const borderWidth = this.layout!.yoga.getBorder(Edge.All);\n        const boxSizing = this.layout!.yoga.getBoxSizing();\n        const alignment = boxSizing === BoxSizing.BorderBox ? 1 : 0;\n\n        const layoutStyles = this.layout!.style;\n        const { borderColor, borderRadius } = layoutStyles;\n\n        this._updateBackground(computedLayout);\n        this.stroke.clear();\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (borderWidth > 0 && borderColor != null) {\n            this.stroke.roundRect(0, 0, computedLayout.width, computedLayout.height, borderRadius ?? 0);\n            this.stroke.stroke({ color: borderColor, width: borderWidth, alignment });\n        }\n\n        // Handle overflow\n        const overflow = this.layout?.style.overflow;\n\n        if (overflow !== 'visible') {\n            this._updateMask(computedLayout.width, computedLayout.height, layoutStyles.borderRadius ?? 0);\n            this.setMask({ mask: this._mask });\n            // the max value is actually the difference between the container size and the content size and the stroke\n            const borderOffset = boxSizing === BoxSizing.BorderBox ? borderWidth : 0;\n\n            setTimeout(() => {\n                const maskWidth = computedLayout.width - this.overflowContainer.width - borderOffset * 2;\n                const maskHeight = computedLayout.height - this.overflowContainer.height - borderOffset * 2;\n\n                this._trackpad.xAxis.max = Math.min(0, maskWidth);\n                this._trackpad.yAxis.max = Math.min(0, maskHeight);\n            }, 1);\n        } else {\n            this.mask = null;\n            this._trackpad.xAxis.value = 0;\n            this._trackpad.yAxis.value = 0;\n            this.overflowContainer.position.set(0, 0);\n        }\n    }\n\n    protected update(): void {\n        const overflow = this.layout?.style.overflow;\n\n        if (overflow !== 'scroll') {\n            return;\n        }\n        this._trackpad.update();\n        this.overflowContainer.x = this._trackpad.x;\n        this.overflowContainer.y = this._trackpad.y;\n    }\n\n    public override destroy(options?: DestroyOptions): void {\n        super.destroy(options);\n        Ticker.shared.remove(this.update, this);\n    }\n}\n"],"names":["Container","Graphics","Rectangle","Trackpad","Ticker","Edge","BoxSizing"],"mappings":"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"}