{"version":3,"file":"calculateObjectFit.mjs","sources":["../../../../src/core/mixins/utils/calculateObjectFit.ts"],"sourcesContent":["import { type Bounds } from 'pixi.js';\nimport { type LayoutStyles } from '../../style/layoutStyles';\nimport { type ComputedLayout } from '../../types';\n\n/**\n * Calculates scaling factors for content based on CSS object-fit rules\n * Determines how content should be resized to fit within its container\n *\n * @param value - The object-fit mode to apply ('fill', 'contain', 'cover', 'none', 'scale-down')\n * @param computedLayout - The computed layout dimensions from Yoga\n * @param bounds - The original bounds of the content being sized\n * @returns Object containing x and y scaling factors to apply\n */\nexport function calculateObjectFit(value: LayoutStyles['objectFit'], computedLayout: ComputedLayout, bounds: Bounds) {\n    let offsetScaleX: number = 1;\n    let offsetScaleY: number = 1;\n\n    switch (value) {\n        case 'fill':\n            // Stretch to fill target dimensions\n            offsetScaleX = computedLayout.width / bounds.width;\n            offsetScaleY = computedLayout.height / bounds.height;\n            break;\n\n        case 'contain': {\n            // Scale to fit while maintaining aspect ratio\n            const scaleContain = Math.min(computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n\n            offsetScaleX = scaleContain;\n            offsetScaleY = scaleContain;\n            break;\n        }\n\n        case 'cover': {\n            // Scale to cover while maintaining aspect ratio\n            const scaleCover = Math.max(computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n\n            offsetScaleX = scaleCover;\n            offsetScaleY = scaleCover;\n            break;\n        }\n\n        case 'none':\n            // Use original size\n            offsetScaleX = 1;\n            offsetScaleY = 1;\n            break;\n\n        case 'scale-down': {\n            // Like contain, but never scale up\n            const scaleDown = Math.min(1, computedLayout.width / bounds.width, computedLayout.height / bounds.height);\n\n            offsetScaleX = scaleDown;\n            offsetScaleY = scaleDown;\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    return {\n        offsetScaleX,\n        offsetScaleY,\n    };\n}\n"],"names":[],"mappings":"AAagB,SAAA,mBAAmB,OAAkC,gBAAgC,QAAgB;AACjH,MAAI,eAAuB;AAC3B,MAAI,eAAuB;AAE3B,UAAQ,OAAO;AAAA,IACX,KAAK;AAEc,qBAAA,eAAe,QAAQ,OAAO;AAC9B,qBAAA,eAAe,SAAS,OAAO;AAC9C;AAAA,IAEJ,KAAK,WAAW;AAEN,YAAA,eAAe,KAAK,IAAI,eAAe,QAAQ,OAAO,OAAO,eAAe,SAAS,OAAO,MAAM;AAEzF,qBAAA;AACA,qBAAA;AACf;AAAA,IAAA;AAAA,IAGJ,KAAK,SAAS;AAEJ,YAAA,aAAa,KAAK,IAAI,eAAe,QAAQ,OAAO,OAAO,eAAe,SAAS,OAAO,MAAM;AAEvF,qBAAA;AACA,qBAAA;AACf;AAAA,IAAA;AAAA,IAGJ,KAAK;AAEc,qBAAA;AACA,qBAAA;AACf;AAAA,IAEJ,KAAK,cAAc;AAET,YAAA,YAAY,KAAK,IAAI,GAAG,eAAe,QAAQ,OAAO,OAAO,eAAe,SAAS,OAAO,MAAM;AAEzF,qBAAA;AACA,qBAAA;AACf;AAAA,IAAA;AAAA,EAIA;AAGD,SAAA;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;"}