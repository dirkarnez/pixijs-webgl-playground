{"version":3,"file":"baseComputeLayoutData.cjs","sources":["../../../../src/core/mixins/utils/baseComputeLayoutData.ts"],"sourcesContent":["import { type Container, NineSliceSprite, type ObservablePoint, TilingSprite, type ViewContainer } from 'pixi.js';\nimport { type LayoutStyles } from '../../style/layoutStyles';\nimport { type ComputedLayout, type ComputedPixiLayout } from '../../types';\nimport { calculateObjectFit } from './calculateObjectFit';\nimport { calculatePositionSpecifier } from './calculatePositionSpecifier';\n\n/**\n * Calculates the final position and scale for a container based on its layout\n * Handles object-fit and object-position to determine how content is sized and positioned\n *\n * @param container - The container to calculate layout data for\n * @param computedLayout - The computed layout data from Yoga\n * @param defaultObjectFit - Default object-fit value to use if none specified\n * @param anchor - Optional anchor point for positioning adjustments\n * @returns The final position and scale values to apply\n */\n\nexport function baseComputeLayoutData(\n    container: Container | ViewContainer,\n    computedLayout: ComputedLayout,\n    defaultObjectFit: LayoutStyles['objectFit'],\n    anchor?: ObservablePoint,\n): ComputedPixiLayout {\n    const bounds = container.getLocalBounds();\n\n    const objectFit = container.layout!.style.objectFit || defaultObjectFit;\n    let { offsetScaleX, offsetScaleY } = calculateObjectFit(objectFit, computedLayout, bounds);\n\n    // scale the current bounds by the offset scale\n    const scaledBounds = {\n        width: bounds.width * offsetScaleX,\n        height: bounds.height * offsetScaleY,\n    };\n    let { x: offsetX, y: offsetY } = calculatePositionSpecifier(\n        container.layout!.style.objectPosition,\n        computedLayout,\n        scaledBounds,\n    );\n\n    // offset the anchor point if it exists, otherwise offset by the minX and minY to account for containers with negative x/y\n    if (anchor) {\n        offsetX += bounds.width * offsetScaleX * anchor._x;\n        offsetY += bounds.height * offsetScaleY * anchor._y;\n    } else {\n        offsetX -= bounds.minX * offsetScaleX;\n        offsetY -= bounds.minY * offsetScaleY;\n    }\n\n    const applySizeDirectly = container.layout!.style.applySizeDirectly;\n\n    // If applySizeDirectly is true, set the container's width and height directly\n    if (\n        applySizeDirectly === true ||\n        // eslint-disable-next-line eqeqeq\n        (applySizeDirectly == undefined && (container instanceof TilingSprite || container instanceof NineSliceSprite))\n    ) {\n        container.width = bounds.width * offsetScaleX;\n        container.height = bounds.height * offsetScaleY;\n        offsetScaleX = 1;\n        offsetScaleY = 1;\n    }\n\n    return {\n        x: computedLayout.left,\n        y: computedLayout.top,\n        offsetX,\n        offsetY,\n        scaleX: offsetScaleX,\n        scaleY: offsetScaleY,\n    };\n}\n"],"names":["calculateObjectFit","calculatePositionSpecifier","TilingSprite","NineSliceSprite"],"mappings":";;;;;AAiBO,SAAS,sBACZ,WACA,gBACA,kBACA,QACkB;AACZ,QAAA,SAAS,UAAU,eAAe;AAExC,QAAM,YAAY,UAAU,OAAQ,MAAM,aAAa;AACvD,MAAI,EAAE,cAAc,iBAAiBA,mBAAmB,mBAAA,WAAW,gBAAgB,MAAM;AAGzF,QAAM,eAAe;AAAA,IACjB,OAAO,OAAO,QAAQ;AAAA,IACtB,QAAQ,OAAO,SAAS;AAAA,EAC5B;AACA,MAAI,EAAE,GAAG,SAAS,GAAG,QAAY,IAAAC,2BAAA;AAAA,IAC7B,UAAU,OAAQ,MAAM;AAAA,IACxB;AAAA,IACA;AAAA,EACJ;AAGA,MAAI,QAAQ;AACG,eAAA,OAAO,QAAQ,eAAe,OAAO;AACrC,eAAA,OAAO,SAAS,eAAe,OAAO;AAAA,EAAA,OAC9C;AACH,eAAW,OAAO,OAAO;AACzB,eAAW,OAAO,OAAO;AAAA,EAAA;AAGvB,QAAA,oBAAoB,UAAU,OAAQ,MAAM;AAGlD,MACI,sBAAsB;AAAA,EAErB,qBAAqB,WAAc,qBAAqBC,QAAA,gBAAgB,qBAAqBC,QAChG,kBAAA;AACY,cAAA,QAAQ,OAAO,QAAQ;AACvB,cAAA,SAAS,OAAO,SAAS;AACpB,mBAAA;AACA,mBAAA;AAAA,EAAA;AAGZ,SAAA;AAAA,IACH,GAAG,eAAe;AAAA,IAClB,GAAG,eAAe;AAAA,IAClB;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA,EACZ;AACJ;;"}