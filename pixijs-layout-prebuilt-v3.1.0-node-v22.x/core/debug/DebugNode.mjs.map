{"version":3,"file":"DebugNode.mjs","sources":["../../../src/core/debug/DebugNode.ts"],"sourcesContent":["import { Container, Graphics, type PointData, type Rectangle } from 'pixi.js';\nimport { DebugRegionType } from './calculateDebugRegions';\n\n/**\n * Represents a debug region with its visual properties\n */\nexport interface DebugNodeRegion {\n    outer: Rectangle; // Outer bounds of the region\n    inner: Rectangle; // Inner bounds (for cut-out regions)\n    color: string; // Color used to render the region\n    draw: boolean; // Whether to render this region\n}\n\nfunction lerpColor(start: [number, number, number], end: [number, number, number], t: number): string {\n    const r = Math.round(start[0] + (end[0] - start[0]) * t);\n    const g = Math.round(start[1] + (end[1] - start[1]) * t);\n    const b = Math.round(start[2] + (end[2] - start[2]) * t);\n\n    return `rgb(${r},${g},${b})`;\n}\n\n/**\n * Visual debug object that renders layout regions\n */\nexport class DebugNode extends Container {\n    /** Graphics objects for each region type */\n    private readonly graphics: Map<DebugRegionType, Graphics>;\n    private readonly heatGraphics: Graphics;\n\n    constructor() {\n        super();\n        this.graphics = new Map();\n\n        // Create a graphics object for each region type\n        Object.values(DebugRegionType).forEach((type) => {\n            const graphics = new Graphics();\n\n            this.graphics.set(type, graphics);\n            this.addChild(graphics);\n        });\n        this.heatGraphics = new Graphics();\n        this.addChild(this.heatGraphics);\n    }\n\n    /**\n     * Initialize the debug object with region data\n     */\n    init(\n        regions: Record<DebugRegionType, DebugNodeRegion> & {\n            target: PointData;\n            alpha: number;\n            heat: { invalidationCount: number; draw: boolean };\n            heatOnly: boolean;\n        },\n    ): void {\n        const { target, alpha, heat } = regions;\n\n        if (!regions.heatOnly) {\n            // Draw each region\n            Object.entries(regions).forEach(([type, region]) => {\n                if (type === 'target' || type === 'alpha' || type === 'heat' || type === 'heatOnly') return;\n\n                region = region as DebugNodeRegion;\n                const graphics = this.graphics.get(type as DebugRegionType);\n\n                if (!graphics || !region.draw) return;\n\n                // Draw either a cut box (for regions with inner area) or a solid box\n                if (region.inner) {\n                    this.drawCutBox(graphics, region.outer, region.inner, region.color, alpha);\n                } else {\n                    const { x, y, width, height } = region.outer;\n\n                    graphics.rect(x, y, width, Math.max(height, 1));\n                    graphics.fill({ color: region.color, alpha });\n                }\n            });\n        }\n\n        const { invalidationCount, draw } = heat;\n\n        if (invalidationCount > 0 && draw) {\n            const MAX_INVALIDATE_COUNT = 20;\n            const normalizedAlpha = Math.min(invalidationCount / MAX_INVALIDATE_COUNT, 1);\n            const marginRegion = regions[DebugRegionType.Margin];\n            const startColor = [255, 255, 0] as [number, number, number]; // Yellow\n            const endColor = [255, 0, 0] as [number, number, number]; // Red\n            const color = lerpColor(startColor, endColor, normalizedAlpha);\n\n            this.heatGraphics.rect(\n                marginRegion.outer.x,\n                marginRegion.outer.y,\n                marginRegion.outer.width,\n                marginRegion.outer.height,\n            );\n            this.heatGraphics.fill({ color, alpha: Math.min(0.3, normalizedAlpha) });\n            this.heatGraphics.stroke({ color, alpha: Math.max(0.3, normalizedAlpha), pixelLine: true });\n        }\n\n        this.position.set(target.x, target.y);\n    }\n\n    /**\n     * Reset the debug object's state\n     */\n    reset(): void {\n        this.graphics.forEach((graphics) => graphics.clear());\n        this.heatGraphics.clear();\n        this.removeFromParent();\n    }\n\n    /**\n     * Draw a box with a cut-out center\n     */\n    private drawCutBox(graphics: Graphics, outer: Rectangle, inner: Rectangle, color: string, alpha: number): void {\n        const { x, y, width, height } = outer;\n        const { x: innerX, y: innerY, width: innerWidth, height: innerHeight } = inner;\n\n        // Draw outer box and cut out inner area\n        graphics.rect(x, y, width, height);\n        graphics.fill({ color, alpha });\n        graphics.rect(innerX, innerY, innerWidth, innerHeight);\n        graphics.cut();\n    }\n}\n"],"names":["Graphics"],"mappings":";;;;;AAaA,SAAS,UAAU,OAAiC,KAA+B,GAAmB;AAClG,QAAM,IAAI,KAAK,MAAM,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC;AACvD,QAAM,IAAI,KAAK,MAAM,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC;AACvD,QAAM,IAAI,KAAK,MAAM,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC;AAEvD,SAAO,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;AAC7B;AAKO,MAAM,kBAAkB,UAAU;AAAA,EAKrC,cAAc;AACJ,UAAA;AAJO;AAAA;AACA;AAIR,SAAA,+BAAe,IAAI;AAGxB,WAAO,OAAO,eAAe,EAAE,QAAQ,CAAC,SAAS;AACvC,YAAA,WAAW,IAAIA,WAAS;AAEzB,WAAA,SAAS,IAAI,MAAM,QAAQ;AAChC,WAAK,SAAS,QAAQ;AAAA,IAAA,CACzB;AACI,SAAA,eAAe,IAAIA,WAAS;AAC5B,SAAA,SAAS,KAAK,YAAY;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAMnC,KACI,SAMI;AACJ,UAAM,EAAE,QAAQ,OAAO,KAAS,IAAA;AAE5B,QAAA,CAAC,QAAQ,UAAU;AAEZ,aAAA,QAAQ,OAAO,EAAE,QAAQ,CAAC,CAAC,MAAM,MAAM,MAAM;AAChD,YAAI,SAAS,YAAY,SAAS,WAAW,SAAS,UAAU,SAAS,WAAY;AAE5E,iBAAA;AACT,cAAM,WAAW,KAAK,SAAS,IAAI,IAAuB;AAE1D,YAAI,CAAC,YAAY,CAAC,OAAO,KAAM;AAG/B,YAAI,OAAO,OAAO;AACT,eAAA,WAAW,UAAU,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,KAAK;AAAA,QAAA,OACtE;AACH,gBAAM,EAAE,GAAG,GAAG,OAAO,OAAA,IAAW,OAAO;AAE9B,mBAAA,KAAK,GAAG,GAAG,OAAO,KAAK,IAAI,QAAQ,CAAC,CAAC;AAC9C,mBAAS,KAAK,EAAE,OAAO,OAAO,OAAO,OAAO;AAAA,QAAA;AAAA,MAChD,CACH;AAAA,IAAA;AAGC,UAAA,EAAE,mBAAmB,KAAA,IAAS;AAEhC,QAAA,oBAAoB,KAAK,MAAM;AAC/B,YAAM,uBAAuB;AAC7B,YAAM,kBAAkB,KAAK,IAAI,oBAAoB,sBAAsB,CAAC;AACtE,YAAA,eAAe,QAAQ,gBAAgB,MAAM;AACnD,YAAM,aAAa,CAAC,KAAK,KAAK,CAAC;AAC/B,YAAM,WAAW,CAAC,KAAK,GAAG,CAAC;AAC3B,YAAM,QAAQ,UAAU,YAAY,UAAU,eAAe;AAE7D,WAAK,aAAa;AAAA,QACd,aAAa,MAAM;AAAA,QACnB,aAAa,MAAM;AAAA,QACnB,aAAa,MAAM;AAAA,QACnB,aAAa,MAAM;AAAA,MACvB;AACK,WAAA,aAAa,KAAK,EAAE,OAAO,OAAO,KAAK,IAAI,KAAK,eAAe,GAAG;AACvE,WAAK,aAAa,OAAO,EAAE,OAAO,OAAO,KAAK,IAAI,KAAK,eAAe,GAAG,WAAW,KAAA,CAAM;AAAA,IAAA;AAG9F,SAAK,SAAS,IAAI,OAAO,GAAG,OAAO,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAMxC,QAAc;AACV,SAAK,SAAS,QAAQ,CAAC,aAAa,SAAS,OAAO;AACpD,SAAK,aAAa,MAAM;AACxB,SAAK,iBAAiB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAMlB,WAAW,UAAoB,OAAkB,OAAkB,OAAe,OAAqB;AAC3G,UAAM,EAAE,GAAG,GAAG,OAAO,OAAW,IAAA;AAC1B,UAAA,EAAE,GAAG,QAAQ,GAAG,QAAQ,OAAO,YAAY,QAAQ,YAAA,IAAgB;AAGzE,aAAS,KAAK,GAAG,GAAG,OAAO,MAAM;AACjC,aAAS,KAAK,EAAE,OAAO,MAAA,CAAO;AAC9B,aAAS,KAAK,QAAQ,QAAQ,YAAY,WAAW;AACrD,aAAS,IAAI;AAAA,EAAA;AAErB;"}