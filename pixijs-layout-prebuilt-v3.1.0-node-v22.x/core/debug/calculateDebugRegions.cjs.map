{"version":3,"file":"calculateDebugRegions.cjs","sources":["../../../src/core/debug/calculateDebugRegions.ts"],"sourcesContent":["import { Bounds, Rectangle } from 'pixi.js';\nimport { Edge, FlexDirection } from 'yoga-layout/load';\n\nimport type { Layout } from '../Layout';\n\ntype DebugRegionRects = {\n    outer: Rectangle; // Outer bounds of the region\n    inner: Rectangle; // Inner bounds (for cut-out regions)\n};\n\nexport type DebugRegions = Map<DebugRegionType, DebugRegionRects>;\n\n/**\n * Types of regions that can be debugged in the yoga layout\n */\nexport enum DebugRegionType {\n    Margin = 'margin', // Outer spacing around element\n    Padding = 'padding', // Inner spacing within element\n    Border = 'border', // Border area between margin and padding\n    Flex = 'flex', // Flex container area\n    Content = 'content', // Content area inside padding\n}\n\n/**\n * Edge measurements for margin, padding, or border\n */\ninterface EdgeValues {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n}\n\n/**\n * Get the edge values for margin, padding, or border\n */\nfunction getEdgeValues(layout: Layout, type: 'margin' | 'padding' | 'border'): EdgeValues {\n    const method = `getComputed${type.charAt(0).toUpperCase() + type.slice(1)}` as\n        | 'getComputedMargin'\n        | 'getComputedPadding'\n        | 'getComputedBorder';\n\n    return {\n        top: layout.yoga[method](Edge.Top),\n        right: layout.yoga[method](Edge.Right),\n        bottom: layout.yoga[method](Edge.Bottom),\n        left: layout.yoga[method](Edge.Left),\n    };\n}\n\n/**\n * Calculates and updates the debug regions (margin, border, and padding) for a given layout.\n * This function modifies the provided `regions` object to reflect the computed bounds\n * and edge values (margin, border, and padding) of the layout.\n *\n * @param layout - The layout object containing computed bounds and edge values.\n * @param regions - A map of debug region types to their corresponding debug region objects.\n *                  The function updates the regions for margin, border, and padding.\n */\nexport function calculateRegions(layout: Layout, regions: DebugRegions): void {\n    const { width, height } = layout.computedLayout;\n    const margin = getEdgeValues(layout, 'margin');\n    const border = getEdgeValues(layout, 'border');\n    const padding = getEdgeValues(layout, 'padding');\n\n    // Margin region\n    const marginRegion = regions.get(DebugRegionType.Margin)!;\n\n    marginRegion.outer.x = -margin.left;\n    marginRegion.outer.y = -margin.top;\n    marginRegion.outer.width = width + margin.left + margin.right;\n    marginRegion.outer.height = height + margin.top + margin.bottom;\n\n    marginRegion.inner.x = 0;\n    marginRegion.inner.y = 0;\n    marginRegion.inner.width = width;\n    marginRegion.inner.height = height;\n\n    // Border region\n    const borderRegion = regions.get(DebugRegionType.Border)!;\n\n    borderRegion.outer.x = 0;\n    borderRegion.outer.y = 0;\n    borderRegion.outer.width = width;\n    borderRegion.outer.height = height;\n\n    borderRegion.inner.x = border.left;\n    borderRegion.inner.y = border.top;\n    borderRegion.inner.width = width - border.left - border.right;\n    borderRegion.inner.height = height - border.top - border.bottom;\n\n    // Padding region\n    const paddingRegion = regions.get(DebugRegionType.Padding)!;\n\n    paddingRegion.outer.copyFrom(borderRegion.inner!);\n    paddingRegion.inner.x = padding.left + border.left;\n    paddingRegion.inner.y = padding.top + border.top;\n    paddingRegion.inner.width = width - padding.left - padding.right - border.left - border.right;\n    paddingRegion.inner.height = height - padding.top - padding.bottom - border.top - border.bottom;\n\n    calculateFlexRegion(layout, regions);\n}\n\nfunction calculateFlexRegion(layout: Layout, regions: DebugRegions): void {\n    const flexRegion = regions.get(DebugRegionType.Flex)!;\n    const paddingRegion = regions.get(DebugRegionType.Padding)!;\n\n    flexRegion.outer.copyFrom(paddingRegion.inner!);\n    const bounds = new Bounds();\n\n    const children = layout.yoga.getChildCount();\n\n    for (let i = 0; i < children; i++) {\n        const child = layout.yoga.getChild(i);\n        const computedBounds = child.getComputedLayout();\n\n        // TODO: for this to be accurate we would need to create the bounds per child and then content could be an array\n        bounds.addRect(\n            new Rectangle(computedBounds.left, computedBounds.top, computedBounds.width, computedBounds.height),\n        );\n    }\n\n    const flexDir = layout.yoga.getFlexDirection();\n\n    if (flexDir === FlexDirection.Column || flexDir === FlexDirection.ColumnReverse) {\n        bounds.width = flexRegion.outer.width;\n        bounds.x = flexRegion.outer.x;\n    } else {\n        bounds.height = flexRegion.outer.height;\n        bounds.y = flexRegion.outer.y;\n    }\n\n    flexRegion.inner?.copyFrom(bounds.rectangle);\n    regions.get(DebugRegionType.Content)!.outer.copyFrom(bounds.rectangle);\n}\n"],"names":["DebugRegionType","Edge","Bounds","Rectangle","FlexDirection"],"mappings":";;;;AAeY,IAAA,oCAAAA,qBAAL;AACHA,mBAAA,QAAS,IAAA;AACTA,mBAAA,SAAU,IAAA;AACVA,mBAAA,QAAS,IAAA;AACTA,mBAAA,MAAO,IAAA;AACPA,mBAAA,SAAU,IAAA;AALFA,SAAAA;AAAA,GAAA,mBAAA,CAAA,CAAA;AAqBZ,SAAS,cAAc,QAAgB,MAAmD;AAChF,QAAA,SAAS,cAAc,KAAK,OAAO,CAAC,EAAE,YAAgB,IAAA,KAAK,MAAM,CAAC,CAAC;AAKlE,SAAA;AAAA,IACH,KAAK,OAAO,KAAK,MAAM,EAAEC,KAAAA,KAAK,GAAG;AAAA,IACjC,OAAO,OAAO,KAAK,MAAM,EAAEA,KAAAA,KAAK,KAAK;AAAA,IACrC,QAAQ,OAAO,KAAK,MAAM,EAAEA,KAAAA,KAAK,MAAM;AAAA,IACvC,MAAM,OAAO,KAAK,MAAM,EAAEA,UAAK,IAAI;AAAA,EACvC;AACJ;AAWgB,SAAA,iBAAiB,QAAgB,SAA6B;AAC1E,QAAM,EAAE,OAAO,OAAO,IAAI,OAAO;AAC3B,QAAA,SAAS,cAAc,QAAQ,QAAQ;AACvC,QAAA,SAAS,cAAc,QAAQ,QAAQ;AACvC,QAAA,UAAU,cAAc,QAAQ,SAAS;AAGzC,QAAA,eAAe,QAAQ;AAAA,IAAI;AAAA;AAAA,EAAsB;AAE1C,eAAA,MAAM,IAAI,CAAC,OAAO;AAClB,eAAA,MAAM,IAAI,CAAC,OAAO;AAC/B,eAAa,MAAM,QAAQ,QAAQ,OAAO,OAAO,OAAO;AACxD,eAAa,MAAM,SAAS,SAAS,OAAO,MAAM,OAAO;AAEzD,eAAa,MAAM,IAAI;AACvB,eAAa,MAAM,IAAI;AACvB,eAAa,MAAM,QAAQ;AAC3B,eAAa,MAAM,SAAS;AAGtB,QAAA,eAAe,QAAQ;AAAA,IAAI;AAAA;AAAA,EAAsB;AAEvD,eAAa,MAAM,IAAI;AACvB,eAAa,MAAM,IAAI;AACvB,eAAa,MAAM,QAAQ;AAC3B,eAAa,MAAM,SAAS;AAEf,eAAA,MAAM,IAAI,OAAO;AACjB,eAAA,MAAM,IAAI,OAAO;AAC9B,eAAa,MAAM,QAAQ,QAAQ,OAAO,OAAO,OAAO;AACxD,eAAa,MAAM,SAAS,SAAS,OAAO,MAAM,OAAO;AAGnD,QAAA,gBAAgB,QAAQ;AAAA,IAAI;AAAA;AAAA,EAAuB;AAE3C,gBAAA,MAAM,SAAS,aAAa,KAAM;AAChD,gBAAc,MAAM,IAAI,QAAQ,OAAO,OAAO;AAC9C,gBAAc,MAAM,IAAI,QAAQ,MAAM,OAAO;AAC/B,gBAAA,MAAM,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,QAAQ,OAAO,OAAO,OAAO;AAC1E,gBAAA,MAAM,SAAS,SAAS,QAAQ,MAAM,QAAQ,SAAS,OAAO,MAAM,OAAO;AAEzF,sBAAoB,QAAQ,OAAO;AACvC;AAEA,SAAS,oBAAoB,QAAgB,SAA6B;;AAChE,QAAA,aAAa,QAAQ;AAAA,IAAI;AAAA;AAAA,EAAoB;AAC7C,QAAA,gBAAgB,QAAQ;AAAA,IAAI;AAAA;AAAA,EAAuB;AAE9C,aAAA,MAAM,SAAS,cAAc,KAAM;AACxC,QAAA,SAAS,IAAIC,eAAO;AAEpB,QAAA,WAAW,OAAO,KAAK,cAAc;AAE3C,WAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AAC/B,UAAM,QAAQ,OAAO,KAAK,SAAS,CAAC;AAC9B,UAAA,iBAAiB,MAAM,kBAAkB;AAGxC,WAAA;AAAA,MACH,IAAIC,kBAAU,eAAe,MAAM,eAAe,KAAK,eAAe,OAAO,eAAe,MAAM;AAAA,IACtG;AAAA,EAAA;AAGE,QAAA,UAAU,OAAO,KAAK,iBAAiB;AAE7C,MAAI,YAAYC,KAAAA,cAAc,UAAU,YAAYA,KAAAA,cAAc,eAAe;AACtE,WAAA,QAAQ,WAAW,MAAM;AACzB,WAAA,IAAI,WAAW,MAAM;AAAA,EAAA,OACzB;AACI,WAAA,SAAS,WAAW,MAAM;AAC1B,WAAA,IAAI,WAAW,MAAM;AAAA,EAAA;AAGrB,mBAAA,UAAA,mBAAO,SAAS,OAAO;AAClC,UAAQ;AAAA,IAAI;AAAA;AAAA,EAAuB,EAAG,MAAM,SAAS,OAAO,SAAS;AACzE;;;"}